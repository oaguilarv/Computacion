# -*- coding: utf-8 -*-
"""Tarea de Clases y Objetos

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I47xw6HumIlbG7YRS4rhcHWFkI-BCtnR
"""

#PARTE 1: Creación de clase relacionada con conceptos de Matemática

#La clase 'estbasic' involucra conceptos fundamentales de la Estadística. Concretamente,
#conceptos relacionados con la representación numérica de los valores de una variable aleatoria cuantitativa.
#Los objetos pertenecientes a esta clase son listas de números reales, que representarán
#mediciones ordenadas respecto a una variable aleatoria.
#Al ejecutar los métodos definidos en la clase, se obtendrá, para el objeto evaluado,
#las siguientes medidas de localización: 

# * Media aritmética
# * Mediana
# * Moda
# * Valor máximo
# * Valor mínimo
# * Rango

class estbasic :
  def __init__(self, X=[]) :  #init le asigna al objeto ingresado su media aritmética
    m=0
    for i in X :
      m = m+ i
    self.media = m / len(X)
    self.valor = X   #Guardamos el valor de X para poder utilizarlo en los siguientes métodos.
  def Mediana(self) :   #El método Mediana arroja el valor de la mediana de los números ingresados.
    Y=self.valor
    Y.sort()  #Ordenamos de forma creciente nuestras mediciones.
    if (len(Y)%2 == 1) :                   #si el número de mediciones es impar, la mmediana es el valor intermedio de la lista ordenada.
      self.mediana = Y[(len(Y)-1)//2]      
    else :
      self.mediana = (Y[len(Y)//2] + Y[(len(Y)//2)+1]) / 2   #si el número de mediciones es par, la mediana es el promedio de los dos números intermedios de la lista ordenada.
  def Moda(self) : #El método Moda arroja la moda de los números ingresados.
    X = self.valor
    largo=len(X)
    A=[]    #A es una lista que contendrá el número de veces que aparece cada medición.
            #De modo que el elemento i de A es el número de veces que aparece el elemento X[i] en X.
    for i in range(0, largo) :
      cont = 0  #cont va a ir contando el número de veces que aparece cada elemento en X.
      for j in X :
        if j == X[i] :
          cont = cont + 1
      A.append(cont)
    B = list(A) #Ahora B es la lista de frecuencias de las mediciones tomadas.
    A.sort()  #Ahora A es la lista de frecuencias de las mediciones, ordenadas de forma creciente.
               #Así, A[largo-1] es la mayor frecuencia de las mediciones tomadas.
    if largo == 1 :
      print('La moda es: ', X[0])
    elif A[largo-1] == 1 :
      print('No hay moda, ya que todos las mediciones ingresadas aparecen sólo una vez cada una')
    else :
      M=set()  #M contendrá las mediciones que se repiten un número de veces igual a A[largo-1]
    for i in range(0, largo) :
      if B[i] == A[largo-1] : 
        M.add(X[i])
    self.moda = M  
  def Maximo(self) :  #El método Maximo arroja el valor máximo entre los números ingresados.
    X = self.valor
    X.sort()
    self.maximo = X[len(X)-1]
  def Minimo(self) :  #El método Minimo arroja el valor mínimo entre los números ingresados.
    X = self.valor
    X.sort()
    self.minimo = X[0]
  def Rango(self) : #El método Rango arroja el rango de la variable aleatoria respecto a las mediciones ingresadas.
    self.Moda() 
    self.Maximo()
    self.Minimo()
    self.rango = self.maximo - self.minimo

#Creemos 2 objetos (g y K) de la clase estbasic :
g = estbasic([2,2,5,6,7,8,9,8]) 
g.Mediana()
g.Moda()
g.Maximo()
g.Minimo()
g.Rango()
print('Medidas de localización para mediciones #1: \n\n\n')
print('La media artmética es: ', g.media)
print('La mediana es: ', g.mediana)
print('La(s) moda(s) es / son : ', g.moda )
print('El máximo es: ', g.maximo)
print('El mínimo es: ', g.minimo)
print('El rango es: ', g.rango)

k = estbasic([3,3,3,6,6,6,7,10,11,43,56,78])
k.Mediana()
k.Moda()
k.Maximo()
k.Minimo()
k.Rango()
print('\n\n\n Medidas de localización para mediciones #2 : \n\n\n')
print('La media artmética es: ', k.media)
print('La mediana es: ', k.mediana)
print('La(s) moda(s) es / son : ', k.moda )
print('El máximo es: ', k.maximo)
print('El mínimo es: ', k.minimo)
print('El rango es: ', k.rango)

#Ahora, crearemos la subclase 'estplus' de 'estbassic', la cual, además de arrojar medidas de localización, también arrojará dos medidas de dispersión, a saber:
# *La varianza
# *La desviación típica.

class estplus(estbasic) :
  def Varianza(self) :
    X=self.valor
    sumacuad = 0
    for i in X :
      sumacuad = sumacuad + (i-self.media)**2
    self.varianza = sumacuad / len(X)
  def Desvitipic(self) :
    X=self.valor
    self.Varianza()
    self.desvitipic = (self.varianza)**(1/2)

#Creemos dos objetos (a y b) de la subclase 'estplus' de la clase 'estbasic':
a=estplus([10,10,10,-8,-1,-24])
a.Mediana()
a.Moda()
a.Maximo()
a.Minimo()
a.Rango()
a.Varianza()
a.Desvitipic()
print('\n\n\n Medidas de localización y dispersión para mediciones #3 : \n\n\n')
print('La media artmética es: ', a.media)
print('La mediana es: ', a.mediana)
print('La(s) moda(s) es / son : ', a.moda )
print('El máximo es: ', a.maximo)
print('El mínimo es: ', a.minimo)
print('El rango es: ', a.rango)
print('La varianza es: ', a.varianza)
print('La desviación típica es: ', a.desvitipic)

b=estplus([50,50,20,10,40,-40])
b.Mediana()
b.Moda()
b.Maximo()
b.Minimo()
b.Rango()
b.Varianza()
b.Desvitipic()
print('\n\n\n Medidas de localización y dispersión para mediciones #4 : \n\n\n')
print('La media artmética es: ', b.media)
print('La mediana es: ', b.mediana)
print('La(s) moda(s) es / son : ', b.moda )
print('El máximo es: ', b.maximo)
print('El mínimo es: ', b.minimo)
print('El rango es: ', b.rango)
print('La varianza es: ', b.varianza)
print('La desviación típica es: ', b.desvitipic)

#Posibles extensiones de estas clases: Podríamos considerar crear una clase que contenga métodos que arrojen medidas de dispersión especiales, como la MEDA, así como medidas de posición relativa 
#(cuartiles, percentiles y rango intercuartílico). También, coeficientes relevantes en Estadística, como lo son el coeficiente de simetría, de apuntamiento y de variación. Finalmente, que contenga 
#un método para determinar valores atípicos, si los hay.
#Estas clases pueden resultar útiles para estudiantes de Ciencias que están comenzando sus estudios en Estadística, ya que les permite obtener de manera eficiente las medidas comunmente usadas
#en esta Rama.



#PARTE 2: Creación de clase no relacionada con conceptos matemáticos

#La clase 'guardarropa' describe objetos que son cuaternas de números naturales (listas de 4 números naturales).
#El primer, segundo, tercer y cuarto elemento de la lista representan, respectivamente, el número
#de camisetas, pantalones, suéteres y zapatos que tiene una persona en su guardarropas. 
#Al ejecutar los métodos definidos en esta clase, se obtendrán, para el objeto evaluado,
#los siguientes datos:
#Número total de prendas de ropa,
#Número de camisetas,
#Número de pantalones,
#Número de suéteres,
#Número de zapatos,
#Número de posibles atuendos que pueden formarse con las prendas de ropa (usando sólo un item de cada categoría).


class guardarropa :
  def __init__(self, X=[]) : #Al ejecutare init, obtenemos el número de prendas de ropa con las que cuenta la persona-
    suma = 0
    for i in X :
      suma = suma + i
    self.totalprendas = suma  
    self.valor = X
  def Camisetas(self) :  #El método 'Camisetas' arroja el número de camisetas que tiene la persona.
    X=self.valor
    self.camisetas = X[0]
  def Pantalones(self) : #El método 'Pantalones' arroja el número de pantalones que tiene la persona.
    X=self.valor
    self.pantalones = X[1]
  def Sueteres(self) : #El método 'Sueteres' arroja el número de suéteres que tiene la persona.
    X=self.valor
    self.sueteres = X[2]
  def Zapatos(self) : #El método 'Zapatos' arroja el número de zapatos que tiene la persona.
    X=self.valor 
    self.zapatos = X[3]
  def Atuendos(self) : #El método 'Atuendos' arroja el número total de atuendos o outfits que la persona puede llevar puestos.
    X=self.valor
    self.atuendos = X[0]*X[1]*X[2]*X[3] #Por el Principio del producto, ésta es la cantidad de atuendos posibles si usa sólo un item de cada categoría.
  
#Creemos un objeto de esta clase:
a=guardarropa([10,10,15,48])
a.Camisetas()
a.Pantalones()
a.Sueteres()
a.Zapatos()
a.Atuendos()
print('\n\n\n Datos del guardarropa #1: \n\n\n')
print('Tu número de camisetas es: ', a.camisetas)
print('Tu número de pantalones es: ', a.pantalones)
print('Tu número de suéteres es : ', a.sueteres )
print('Tu númmero de zapatos es: ', a.zapatos)
print('Tu número de atuendos es: ', a.atuendos)

#Ahora, crearemos la subclase 'sinalgo' de la clase 'guardarropa', la cual también arrojará la cantidad de atuendos que no llevan sueter y la cantidad de atuendos que no llevan camiseta.
class sinalgo(guardarropa) :  
  print(  )
  def Sinsueter(self) :
    X=self.valor
    self.sinsueter = X[0]*X[1]*X[3] #Por el Principio del producto
  def Sincamiseta(self) :
    X=self.valor
    self.sincamiseta = X[1]*X[2]*X[3] #Principio del Producto

#Creemos un objeto de la subclase 'sinalgo':
h=sinalgo([2,3,4,5])   
h.Zapatos()
h.Sinsueter()
h.Sincamiseta()
print('\n\n\n Datos del guardarropa #2: \n\n\n')
print('Tu número de prendas de ropa es: ', h.totalprendas)
print('Tu número de zapatos es: ', h.zapatos)
print('Tu número de atuendos sin sueter es: ', h.sinsueter)
print('Tu número de atuendos sin camiseta es : ', h.sincamiseta)

#Posibles extensiones de estas dos clases: Usando diccionarios, podemos generalizar estas clases para n categorías de prendas (por ejemplo, medias, bufandas, gafas, etc.). También, aparte de ingresar 
#la cantidad de prendas de cada categoría, podríamos ingresar una lista con la cantidad de prendas que nos gustan, de cada categoría, y crear métodos que arrojen
#la cantidad de atuendos que nos gustan completamente (es decir, que las prendas que lo conformen nos gusten todas),
#y la cantidad de atuendos que no nos gustan del todo (los que tienen al menos una prenda que no nos gusta).
#Estas clases pueden ayudar a una persona a organizar su guardarropa, saber con qué prendas cuenta y obtener información sobre sus outfits.